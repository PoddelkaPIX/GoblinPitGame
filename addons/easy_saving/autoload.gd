extends Node


## Autoload generated by the "GES - Godot Easy Saving" addon.
## This autoload manages all code related to the addon.
## Contributions are welcome! Feel free to open a Pull Request or report issues in the Issues section.


## This signal is emitted whenever a save file is loaded, regardless if it loaded corretly or not.
## Any errors are passed via [param error].
signal load_finished(error: Error)

## This signal is emitted whenever a save file is saved.
## The slot the file was saved to is passed via [param slot] and the file data is passed via [param saved_data].
signal save_finished(slot: int, saved_data: Dictionary)

## This signal is emitted whenever the data of the currently loaded save file changes.
## The new data is passed via [param new_data].
signal data_changed(new_data: Dictionary)


## The save files and encryption files path.
const FOLDER_PATH := "user://save/"


## The current data of the save file.
var data := {}

## The last slot accessed. Changes when a save file is loaded or saved to match the corresponding slot of the operation.
var cur_slot := 0

## The amount of times the file was autosaved.
var autosave_count := 0

## The password used to encrypt save files. Unique to every single user.
var password := OS.get_unique_id()


func _ready() -> void:
	# Make sure this autoload runs even when the game is paused.
	process_mode = Node.PROCESS_MODE_ALWAYS
	
	# Prevent the game from closing before the save allows it.
	ProjectSettings.set_setting("application/config/auto_accept_quit", false)


func _process(_delta: float) -> void:
	# Check if autosaving is enabled.
	var autosave_interval: float = SaveHelper.get_setting("autosave_interval", 0.0)
	if autosave_interval <= 0.0:
		return
	
	# Check if enough time has passed.
	var elapsed_secs := Time.get_ticks_msec() / 1000.0
	if elapsed_secs <= (autosave_interval + autosave_count) * 60.0:
		return
	
	# Debug log.
	var debug_log: bool = SaveHelper.get_setting("debug_log", true)
	if debug_log:
		print("Autosaving...")
	
	# Save.
	autosave_count += 1
	save_file(cur_slot)


func _notification(what: int) -> void:
	# Check if the project is about to be closed.
	if what != NOTIFICATION_WM_CLOSE_REQUEST:
		return
	
	# Save the data if necessay.
	var save_on_quit: bool = SaveHelper.get_setting("save_on_quit", true)
	var debug_log: bool = SaveHelper.get_setting("debug_log", true)
	if save_on_quit:
		save_file(cur_slot)
	
	# Quit.
	await save_finished
	
	if debug_log:
		print("Quitting...")
	
	get_tree().quit()


## Sets the [member data] [param key] to [param value] and emits [signal data_changed].
func push(key: String, value: Variant) -> void:
	# User can use an "/" to access sub dictionaries.
	var nested_dicts: PackedStringArray = key.split("/")
	
	# Don't do any complex operations if the user is not trying to access a sub dict.
	if nested_dicts.size() <= 1:
		# Set "key" value to "value".
		data[key] = value
		return
	
	# Find the last nested dict.
	var dict: Dictionary = data[key]
	nested_dicts.remove_at(0)
	for dict_name: String in nested_dicts:
		dict = dict[dict_name]
	
	# Set "key" value to "value".
	dict[key] = value


## Returns the [member data] [param key] current value. If it doesn't exist, [param default] is returned instead.
func pull(key: String, default: Variant = null) -> Variant:
	# User can use an "/" to access sub dictionaries.
	var nested_dicts: PackedStringArray = key.split("/")
	
	# Don't do any complex operations if the user is not trying to access a sub dict.
	if nested_dicts.size() <= 1:
		# If "key" can be found in "data" - return its value.
		if data.has(key):
			return data[key] 
		
		# If not - return the given default value and print an error.
		push_warning("Trying to pull a key that doesn't exist. Returning the default value instead.")
		return default
	
	# Find the last nested dict.
	var dict: Dictionary = data[key]
	nested_dicts.remove_at(0)
	for dict_name: String in nested_dicts:
		dict = dict[dict_name]
	
	# If "key" can be found in the last nested dict - return its value.
	if data.has(key):
		return data[key]
	
	# If not - return the given default value and print an error.
	push_warning("Trying to pull a key that doesn't exist. Returning the default value instead.")
	return default


## Loads the save file that corresponds to [param slot]. If the file doesn't exist, the default data is loaded instead.
func load_file(slot: int = 0) -> void:
	# Check if slot is a positive number.
	assert(slot >= 0, "Slot must be a positive number.")
	
	# Load the file.
	cur_slot = slot
	data = load_from_path(SaveHelper.get_save_file_path(slot), SaveHelper.is_slot_encrypted(slot))
	
	# Try to repair the file if it's damaged.
	var auto_repair: bool = SaveHelper.get_setting("auto_repair", true)
	var match_types: bool = SaveHelper.get_setting("match_types", true)
	var debug_log: bool = SaveHelper.get_setting("debug_log", true)
	
	if auto_repair:
		repair_keys()
	
	if match_types:
		repair_types()
	
	if debug_log:
		print("Data result after repairs: " + str(data))


## Saves the current [member data] to the file at the given [param slot]. If a file already exists at the given [param slot], it will be updated.
func save_file(slot: int = 0) -> void:
	# Check if slot is a positive number.
	assert(slot >= 0, "Slot must be a positive number.")
	
	# Get addon settings.
	cur_slot = slot
	
	var debug_log: bool = SaveHelper.get_setting("debug_log", true)
	var is_encrypted: bool = SaveHelper.get_setting("encrypt", true)
	
	# Create variables.
	var encryption_path := SaveHelper.get_encryption_file_path(slot)
	var file_path := SaveHelper.get_save_file_path(slot)
	
	# Create a folder to store all the save files if it doesn't exists yet.
	if not DirAccess.dir_exists_absolute(FOLDER_PATH):
		DirAccess.make_dir_absolute(FOLDER_PATH)
		
		if debug_log:
			print("Couldn't find saves folder. Created one just now.\nLocation: user://save/")
	
	# Create the .cfg file.
	var file: FileAccess
	if is_encrypted:
		file = FileAccess.open_encrypted_with_pass(file_path, FileAccess.WRITE, password)
	else:
		file = FileAccess.open(file_path, FileAccess.WRITE)
	
	# Store contents to the file.
	file.store_var(data)
	
	# Close the file.
	file.close()
	
	# Create or delete a file depending on the encryption state of the file.
	if is_encrypted:
		# Create a file to inform the addon that this save file is encrypted.
		if not FileAccess.file_exists(encryption_path):
			# Create file.
			file = FileAccess.open(encryption_path, FileAccess.WRITE)
			file.close()
			
			# Debug log.
			if debug_log:
				print("Created encryption file at \"%s\" because file \"%s\" is not encrypted." % [encryption_path, str(slot)])
		elif debug_log:
			# Debug log.
			print("No encryption files were created. Found an existing encryption file at \"%s\"." % encryption_path)
	else:
		# Remove a file to inform the addon that this save file is NOT encrypted.
		if FileAccess.file_exists(encryption_path):
			# Remove file.
			DirAccess.remove_absolute(encryption_path)
			
			# Debug log.
			if debug_log:
				print("Removed encryption file at \"%s\" because file \"%s\" is not encrypted." % [encryption_path, str(slot)])
	
	# Log to the console.
	save_finished.emit(slot, data)
	if debug_log:
		print("Successfully save file %s at \"%s\"\tEncrypted: %s." % [str(slot), file_path, str(is_encrypted)])


## Loads a save file at the given [param path].
## If [param encrypted] doesn't match the file's encrypted state this method will fail.
func load_from_path(path: String, is_encrypted: bool) -> Dictionary:
	# Get the default save dictionary to be used in case something goes wrong.
	var debug_log: bool = SaveHelper.get_setting("debug_log", true)
	var default_dict: Dictionary = SaveHelper.get_setting("save", {})
	
	# Log the start of the load operation.
	if debug_log:
		print("Loading file from \"%s\" - Encrypted: %s." % [path, str(is_encrypted)])
	
	# Open the file in the given path.
	var file: FileAccess
	if is_encrypted:
		file = FileAccess.open_encrypted_with_pass(path, FileAccess.READ, password)
	else:
		file = FileAccess.open(path, FileAccess.READ)
	
	# Check for errors in the open process.
	var open_error := FileAccess.get_open_error()
	if open_error != OK:
		# Operation failed.
		printerr(error_string(open_error))
		load_finished.emit(open_error)
		
		return default_dict
	
	# Get the file as data.
	return file.get_var()


## Adds missing keys to the loaded save file and also remove additional keys.
func repair_keys() -> void:
	# Get the default data.
	var default_data: Dictionary = SaveHelper.get_setting("save", {})
	
	# Add missing keys.
	data.merge(default_data)
	
	# Remove additional keys.
	for key: String in data.keys():
		if not default_data.has(key):
			push_warning("Removed additional key \"%s\"." % key)
			data.erase(key)


## Checks if the type of all loaded save file values match the default data types.
## If not, reset the value to default.
func repair_types() -> void:
	# Get the default data.
	var default_data: Dictionary = SaveHelper.get_setting("save", {})
	var debug_log: bool = SaveHelper.get_setting("debug_log", true)
	
	# Loop trough every key.
	for key: String in data.keys():
		# Get values.
		var this_value: Variant = data[key]
		var default_value: Variant = default_data[key]
		
		# Get types.
		var this_type: Variant.Type = typeof(this_value)
		var default_type: Variant.Type = typeof(default_value)
		
		# If the types match - do nothing.
		if this_type == default_type:
			continue
		
		# Forgive ints and floats to prevent confusion.
		var is_forgiven := false
		var forgiven_map: Array[Array] = [
			# Forgive the loaded type if it can be found in the array with the expected type.
			[TYPE_INT, TYPE_FLOAT],
			[TYPE_VECTOR2I, TYPE_VECTOR2],
			[TYPE_VECTOR3I, TYPE_VECTOR3],
			[TYPE_VECTOR4I, TYPE_VECTOR4],
			[TYPE_PACKED_FLOAT32_ARRAY, TYPE_PACKED_FLOAT64_ARRAY, TYPE_PACKED_INT32_ARRAY, TYPE_PACKED_INT64_ARRAY],
		]
		
		for array: Array in forgiven_map:
			if array.has(this_type) and array.has(default_type):
				is_forgiven = true
		
		# But if the types don't match - reset the value to default.
		if is_forgiven:
			continue
		
		push_warning("Value for key \"%s\" don't match its original value: Received %s (%s), expected %s (%s)." % [
			key,
			type_string(this_type),
			str(this_value),
			type_string(default_type),
			str(default_value),
		])
		
		this_value = default_value
		data[key] = this_value
